## 1. READ_UNCOMMITTED
![스크린샷 2024-09-21 오후 10 56 39](https://github.com/user-attachments/assets/fc58c986-232c-4f4e-95ce-824466999e9b)

가장 낮은 트랜잭션 격리 수준으로, 다른 트랜잭션에서 **커밋하지 않은 데이터**를 읽을 수 있다.

- Dirty Read : 다른 트랜잭션에서 **커밋하지 않은 데이터**를 현재 트랜잭션에서 읽을 수 있다. 
`Transaction2`가 커밋되지 않은 데이터를 읽었다가 `Trasaction1`이 롤백하게 되면 **잘못된 데이터를 읽은 것**이 된다.
- Race Condition : 여러 트랜잭션이 동시에 `같은 데이터`를 읽고 수정하면서 **서로의 작업을 덮어씌우게 되어 충돌이 발생**한다. → 예상하지 못한 값이 저장된다.

### 문제1. 동시성 문제 발생
![스크린샷 2024-09-21 오후 11 11 55](https://github.com/user-attachments/assets/f399afa8-17f4-4862-82c5-c75c8a33d162)

1. `thread-1`과 `thread-2`가 동시에 출금을 시도한다.
2. 두 스레드가 **동시에 데이터베이스에서 동일한 잔액을 읽는다.** 따라서 두 스레드 모두 `100원`이라는 잔액을 읽게 된다.
    1. thread-1은 남은 잔액으로 100원을 읽는다.
    2. thread-2도 남은 잔액으로 100원을 읽는다.
3. 두 스레드는 읽은 잔액으로부터 출금을 수행한다.
    1. thread-1은 50원을 출금하여 남은 잔액이 `50원`이 된다.
    2. thread-2는 70원을 출금하여 남은 잔액이 `30원`이 된다.
4. 마지막으로 트랜잭션 커밋을 수행한 값으로 DB에 덮어씌어지게 된다.
    1. thread-1이 수행한 트랜잭션이 먼저 커밋되어 남은 잔액으로 50원이 저장된다.
    2. thread-2를 수행한 트랜잭션이 다음으로 커밋되어 남은 잔액으로 30원을 저장한다. 따라서 **thread-1의 트랜잭션이 저장한 값은 덮어쓰여지게 된다.**
5. 최종적은 DB에 저장된 잔액은 30원이 된다.

⇒ `Race Condition`이 발생하여 하나의 트랜잭션이 커밋한 데이터가 **다른 트랜잭션에 의해 덮어쓰여지는 문제**가 발생한다.
&nbsp;

## 2. READ_COMMITTED
**커밋된 데이터만 읽을 수 있기 때문에** READ_UNCOMMITTED 격리 수준에서 발생하는 `Dirty Read`를 방지할 수 있다. 그러나 여전히 두 스레드가 동시에 실행되어 동일한 값을 읽는 문제가 `동시성 문제`가 발생할 수 있다.
### 문제1. 동시성 문제 발생
![스크린샷 2024-09-21 오후 11 11 55](https://github.com/user-attachments/assets/7bc8324b-7293-4d5c-ae37-0f3d326d4289)

1. `thread-1`과 `thread-2`가 동시에 출금을 시도한다.
2. 두 스레드가 **동시에 데이터베이스에서 동일한 잔액을 읽는다.** 따라서 두 스레드 모두 `100원`이라는 잔액을 읽게 된다.
    1. thread-1은 남은 잔액으로 100원을 읽는다.
    2. thread-2도 남은 잔액으로 100원을 읽는다.
3. 두 스레드는 읽은 잔액으로부터 출금을 수행한다.
    1. thread-1은 50원을 출금하여 남은 잔액이 `50원`이 된다.
    2. thread-2는 70원을 출금하여 남은 잔액이 `30원`이 된다.
4. 마지막으로 트랜잭션 커밋을 수행한 값으로 DB에 덮어씌어지게 된다.
    1. thread-1이 수행한 트랜잭션이 먼저 커밋되어 남은 잔액으로 50원이 저장된다.
    2. thread-2를 수행한 트랜잭션이 다음으로 커밋되어 남은 잔액으로 30원을 저장한다. 따라서 **thread-1의 트랜잭션이 저장한 값은 덮어쓰여지게 된다.**
5. 최종적은 DB에 저장된 잔액은 30원이 된다.

⇒ `Race Condition`이 발생하여 하나의 트랜잭션이 커밋한 데이터가 **다른 트랜잭션에 의해 덮어쓰여지는 문제**가 발생한다.

### 문제2. Dirty Read는 방지하지만 여전히 동시성 문제가 발생한다.
![스크린샷 2024-09-21 오후 11 22 06](https://github.com/user-attachments/assets/f27a2c3c-ae73-46a3-a5dc-5faef8aff00a)

1. `thread-1`이 먼저 출금을 시도한다.
2. thread-1은 데이터베이스에서 `100원`이라는 잔액을 읽는다. 
3. thread-1은 읽은 잔액 100원에서 `50원`을 출금한다. (커밋하기 전)
4. `thread-2`가 출금을 시도한다.
5. thread-2는 **커밋되지 않은 값을 읽을 수 없다.** 따라서 남은 잔액으로 `50원`이 아닌 `100원`을 읽는다. → 커밋되지 않은 값이란 thread-1이 잔액에서 50원을 출금하였으나 트랜잭션 커밋을 하지 않은 상태임을 의미한다.
6. thread-2는 읽은 잔액 100원에서 `70원`을 출금한다. (커밋하기 전)
7. `thread-1`이 트랜잭션에 포함된 모든 쿼리를 정상적으로 수행하고 커밋을 수행한다. 데이터베이스에는 현재 잔액으로 50원이 저장된다.
8. `thread-2`도 작업을 마치고 트랜잭션 커밋을 수행한다. DB에는 현재 잔액으로 30원이 저장된다.
9. 최종적으로 DB에 저장된 잔액은 30원이다.

⇒ `Tranasaction1의` 출금 작업은 무시되고 `Transaction2의` 작업만 반영되는 **동시성 문제**가 여전히 발생한다.
